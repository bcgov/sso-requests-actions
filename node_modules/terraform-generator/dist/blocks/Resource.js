"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
const arguments_1 = require("../arguments");
const types_1 = require("../types");
const _1 = require(".");
/**
 * @category Block
 */
class Resource extends _1.Block {
    /**
     * Construct resource.
     *
     * Refer to Terraform documentation on what can be put as type & arguments.
     *
     * @param type type
     * @param name name
     * @param args arguments
     * @param provisioners provisioners
     */
    constructor(type, name, args, provisioners) {
        super('resource', [type, name], args, provisioners);
        this.type = type;
        this.name = name;
    }
    asArgument() {
        return new arguments_1.Argument(`${this.type}.${this.name}`);
    }
    attr(name) {
        return new arguments_1.Attribute(this, name);
    }
    /**
     * Get provisioners.
     */
    getProvisioners() {
        return this.getInnerBlocks();
    }
    /**
     * Set provisioners.
     */
    setProvisioners(provisioners) {
        this.setInnerBlocks(provisioners);
        return this;
    }
    /**
     * Convert resource into data source.
     *
     * Refer to Terraform documentation on what can be put as arguments.
     *
     * @param options options
     * @param argNames names of resource arguments to converted into data source arguments;
     * use array for name mapping, position 0 = original resource's argument name, position 1 = mapped data source's argument name
     * @param args extra arguments
     */
    toData(options, argNames, args) {
        var _a, _b;
        const type = (_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : this.type;
        const name = (_b = options === null || options === void 0 ? void 0 : options.name) !== null && _b !== void 0 ? _b : this.name;
        if (!args) {
            args = {};
        }
        if (!args['filter']) {
            args['filter'] = [];
        }
        else if (!Array.isArray(args['filter'])) {
            throw new Error('Filter is not an array.');
        }
        for (const argName of argNames) {
            let actualArgName;
            let newArgName;
            if (typeof argName === 'string') {
                actualArgName = argName;
                newArgName = argName;
            }
            else {
                actualArgName = argName[0];
                newArgName = argName[1];
            }
            const arg = this.getArgument(actualArgName);
            if (arg instanceof types_1.Map) {
                for (const mapArgName in arg.arguments) {
                    args['filter'].push({
                        name: `${newArgName}:${mapArgName}`,
                        values: [arg.arguments[mapArgName]]
                    });
                }
            }
            else if (!args[newArgName]) {
                args[newArgName] = arg;
            }
        }
        return new _1.Data(type, name, args);
    }
}
exports.Resource = Resource;
