const axios = require('axios');

const realms = ['onestopauth', 'onestopauth-basic', 'onestopauth-both', 'onestopauth-business'];
const modules = ['keycloak_dev', 'keycloak_test', 'keycloak_prod'];

module.exports = async function run({ github, context, args }) {
  const {
    apiUrl,
    authSecret,
    planOutput,
    planResult,
    prNumber,
    prBranch,
    allowedAdditions,
    allowedDeletions,
    allowedUpdates,
    allowedFileChanges,
  } = args;

  const {
    payload: { pull_request, repository },
  } = context;
  const { changed_files: changedFiles, additions: prAdditions, deletions: prDeletions } = pull_request;
  const isAutoGenerated = prBranch.startsWith('request/');
  console.log(prBranch, isAutoGenerated);

  if (!isAutoGenerated) return;

  console.log({
    apiUrl,
    planOutput,
    planResult,
    prNumber,
    prBranch,
    allowedAdditions,
    allowedDeletions,
    allowedUpdates,
    allowedFileChanges,
  });

  const isAllowedChanges = ({ count, limit, message } = {}) => {
    if (count > limit) {
      console.error(message);
      return false;
    }

    return true;
  };

  const isAllowedToMerge = (data) => {
    const { planDetails, planSuccess } = data;
    if (!planSuccess) throw new Error('terraform plan failed');

    const { changedFiles, tfAdditions, tfUpdates, tfDeletions } = planDetails;

    const checks = [
      { count: changedFiles, limit: Number(allowedFileChanges), message: 'too many files changed' },
      { count: tfAdditions, limit: Number(allowedAdditions), message: 'too many terraform resoures added' },
      { count: tfUpdates, limit: Number(allowedUpdates), message: 'too many terraform resoures updated' },
      { count: tfDeletions, limit: Number(allowedDeletions), message: 'too many terraform resoures deleted' },
    ];

    return checks.every(isAllowedChanges);
  };

  try {
    const moduleMatchRegex = /# module.(.*?\n)/g;
    const resourceStrings = planOutput.match(moduleMatchRegex);
    const resources = [];

    resourceStrings &&
      resourceStrings.forEach((resource) => {
        const realm = realms.filter((realm) => resource.includes(`.${realm}.`));
        if (realm.length > 1) throw new Error('Matched multiple realms');

        const module = modules.filter((module) => resource.includes(`.${module}.`));
        if (module.length > 1) throw new Error('Matched multiple modules');

        const client = resource.match(/module.client_(.*?)(\.)/) ? resource.match(/module.client_(.*?)(\.)/)[1] : 0;
        const action = resource.match(/will be (.*?)(\n)/) ? resource.match(/will be (.*?)(\n)/)[1] : 0;

        const parsedResource = { module: module[0], client, realm: realm[0], action };
        resources.push(parsedResource);
      });

    const tfAdditions = planOutput.match(/Plan: (\d+) to add/) ? planOutput.match(/Plan: (\d+) to add/)[1] : 0;
    const tfUpdates = planOutput.match(/add, (\d+) to change/) ? planOutput.match(/add, (\d+) to change/)[1] : 0;
    const tfDeletions = planOutput.match(/change, (\d+) to destroy/)
      ? planOutput.match(/change, (\d+) to destroy/)[1]
      : 0;

    const planDetails = {
      changedFiles,
      prAdditions,
      prDeletions,
      resources,
      tfAdditions,
      tfUpdates,
      tfDeletions,
    };

    const data = {
      prNumber,
      planSuccess: planResult !== 'failure',
      planDetails,
      repoOwner: repository.owner.login,
      repoName: repository.name,
    };

    data.isAllowedToMerge = isAllowedToMerge(data);

    console.log('sending data,', JSON.stringify(data));
    const updateStatus = () => axios.put(`${apiUrl}?status=plan`, data, { headers: { Authorization: authSecret } });

    let success = false;
    for (let x = 0; x < 5; x++) {
      await updateStatus().then(
        () => (success = true),
        () => (success = false),
      );
      if (success) break;
    }

    if (!success) throw Error('failed to update the plan status');
  } catch (error) {
    await axios.put(
      `${apiUrl}?status=plan`,
      { prNumber: prNumber, planSuccess: false, planDetails: { error } },
      { headers: { Authorization: authSecret } },
    );

    throw error;
  }
};
